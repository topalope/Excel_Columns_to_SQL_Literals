import csv
import sys
from pathlib import Path
import tkinter as tk
from tkinter import filedialog, messagebox


def wrap_for_sql(value: str) -> str:
    """
    Trim whitespace, remove outer single quotes if present,
    then escape internal single quotes and wrap in single quotes.
    """
    value = value.strip()

    # If already wrapped in single quotes, strip them first
    if len(value) >= 2 and value.startswith("'") and value.endswith("'"):
        value = value[1:-1]

    # Escape any internal single quotes for SQL (O'Brien -> O''Brien)
    value = value.replace("'", "''")

    return f"'{value}'"


def process_csv(input_path: Path) -> Path:
    # Read all rows from the CSV
    rows = []
    with input_path.open("r", newline="", encoding="utf-8-sig") as f:
        reader = csv.reader(f)
        for row in reader:
            rows.append(row)

    # Filter out completely empty rows for structure detection
    non_empty_rows = [
        row for row in rows if any(cell.strip() for cell in row)
    ]

    if not non_empty_rows:
        raise ValueError("Input CSV appears to be empty or only whitespace.")

    # Detect if this is effectively a single-column file
    is_single_column = all(len(row) == 1 for row in non_empty_rows)

    output_rows = []

    if is_single_column:
        # Flatten all non-empty single-column values into one row
        flattened_values = [
            cell for row in non_empty_rows for cell in row if cell.strip()
        ]
        quoted = [wrap_for_sql(v) for v in flattened_values]
        # Single row, comma-separated
        output_rows.append(quoted)
    else:
        # General CSV: keep the same shape, just quote each value
        for row in rows:
            # Preserve blank rows
            if not any(cell.strip() for cell in row):
                output_rows.append([])
                continue

            new_row = [wrap_for_sql(cell) for cell in row]
            output_rows.append(new_row)

    # Build output path: same directory, "READY FOR SQL " + original name
    output_name = f"READY FOR SQL {input_path.name}"
    output_path = input_path.with_name(output_name)

    # Write the new CSV
    with output_path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerows(output_rows)

    return output_path


def choose_file_with_dialog() -> Path | None:
    # Create a hidden Tk root just for the dialog
    root = tk.Tk()
    root.withdraw()
    root.update_idletasks()

    file_path = filedialog.askopenfilename(
        title="Select CSV file to make READY FOR SQL",
        filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
    )

    root.destroy()

    if not file_path:
        return None

    return Path(file_path)


def main():
    # If a path is given on command line, still support it.
    if len(sys.argv) >= 2:
        input_path = Path(sys.argv[1])
    else:
        # Otherwise, open a Windows file dialog
        input_path = choose_file_with_dialog()
        if input_path is None:
            # User cancelled
            print("No file selected. Exiting.")
            return

    if not input_path.is_file():
        msg = f"Error: '{input_path}' is not a file or does not exist."
        try:
            # Try to show a message box if we have a GUI
            root = tk.Tk()
            root.withdraw()
            messagebox.showerror("READY FOR SQL", msg)
            root.destroy()
        except Exception:
            print(msg)
        return

    try:
        output_path = process_csv(input_path)
    except Exception as e:
        msg = f"Failed to process CSV: {e}"
        try:
            root = tk.Tk()
            root.withdraw()
            messagebox.showerror("READY FOR SQL", msg)
            root.destroy()
        except Exception:
            print(msg)
        return

    msg = f"Done!\n\nSQL-ready file saved as:\n{output_path}"
    try:
        root = tk.Tk()
        root.withdraw()
        messagebox.showinfo("READY FOR SQL", msg)
        root.destroy()
    except Exception:
        print(msg)


if __name__ == "__main__":
    main()
